<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Volleyball Scoreboard — Fixed Collapsible</title>
    <style>
        :root{
            --bg:#0b0b0b; --fg:#fff;
            --stt:#fbc02d; --git:#1976d2; --bd:#d32f2f; --kk:#388e3c;
            --panel: rgba(255,255,255,0.03);
            --muted: rgba(255,255,255,0.6);
        }
        html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,Arial,Helvetica,sans-serif}
        .wrap{padding:12px;display:flex;flex-direction:column;gap:12px;min-height:100vh;box-sizing:border-box}
        .topbar{display:flex;gap:8px;align-items:center}
        select,button{font-size:1rem;padding:8px 10px;border-radius:8px;border:0;cursor:pointer}
        select{background:var(--panel);color:var(--fg)}
        button.primary{background:#1976d2;color:white}
        button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--fg)}
        .board{display:flex;gap:12px;flex:1;min-height:40vh;align-items:stretch}
        .side{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:12px;padding:14px;position:relative;cursor:pointer;transition:transform .12s}
        .side:active{transform:scale(0.995)}
        .teamName{font-weight:700;font-size:1.6rem;margin-bottom:6px}
        .score{font-weight:900;font-size:18vh;line-height:0.9}
        .controls{display:flex;gap:8px;align-items:center}
        .panel{padding:10px;border-radius:10px;background:var(--panel);display:flex;flex-direction:column;gap:8px}
        .small{padding:6px 8px;font-size:0.9rem;border-radius:6px}
        .muted{color:var(--muted)}
        /* ------------ bottom area + fixed controls ------------ */
        /* Height of the fixed controls bar (keep in sync with JS const FIXED_CONTROLS_HEIGHT) */
        .fixedControls {
            --height:56px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--height);
            background: #071017;
            padding: 8px 12px;
            display: flex;
            justify-content: center;
            gap: 8px;
            border-top: 1px solid rgba(255,255,255,0.04);
            z-index: 1000;
            box-sizing: border-box;
            align-items: center;
        }
        /* place bottomArea *above* the fixed controls (so headers and content are not hidden) */
        .bottomArea{
            position: fixed;
            left:0;
            right:0;
            /* leave room for fixed controls */
            bottom: calc(var(--fixed-controls-offset, 56px));
            background:#071017;
            border-top:1px solid rgba(255,255,255,0.04);
            color:var(--fg);
            z-index: 800;
            box-sizing: border-box;
            padding-bottom: 12px; /* extra breathing room for expanded content */
        }
        /* collapsible */
        .collHeader{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;cursor:pointer; user-select:none}
        .collContent{padding:12px;max-height:42vh;overflow:auto}
        table{width:100%;border-collapse:collapse;color:var(--fg)}
        th,td{padding:8px;border:1px solid rgba(255,255,255,0.04);text-align:center}
        th{background:rgba(255,255,255,0.02)}
        .rosterTable td:first-child, .standingsTable td:first-child{font-weight:700}
        .toast{position:fixed;left:50%;top:20%;transform:translateX(-50%);background:#111;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);display:none}
        @media(max-width:900px){
            .score{font-size:12vh}
            .board{flex-direction:column}
            /* on small screens make bottomArea static (flows after content) and push content above fixed controls */
            .bottomArea{position:static; padding-bottom: calc(var(--fixed-controls-offset,56px)); margin-top:12px;}
            /* ensure the wrap has bottom padding so the last content is scrollable above the fixed controls */
            .wrap{padding-bottom: calc(var(--fixed-controls-offset,56px) + 12px);}
        }
        /* small UX helper so header remains clickable if something overlaps */
        .collHeader{z-index:900}
    </style>
</head>
<body>
<div class="wrap" id="wrap">

    <div class="topbar">
        <div>
            <label class="muted">Select Match</label>
            <select id="matchSelect"></select>
            <button id="newMatchBtn" class="small">New Match</button>
        </div>
        <div style="flex:1"></div>
        <div class="panel">
            <div style="font-size:0.9rem;color:var(--muted)">Match Status</div>
            <div id="statusLabel" style="font-weight:700">idle</div>
        </div>
    </div>

    <div class="board" id="mainContainer">
        <div id="sideA" class="side" style="background:var(--stt)">
            <div class="teamName" id="teamAName">STT — Save The Tigers</div>
            <div id="scoreA" class="score">0</div>
            <div class="controls" style="margin-top:12px">
                <button id="subA" class="small">-1</button>
            </div>
            <div style="margin-top:8px;color:var(--muted)">Tap this panel to +1</div>
        </div>

        <div id="sideB" class="side" style="background:var(--git)">
            <div class="teamName" id="teamBName">GIT — God Is There</div>
            <div id="scoreB" class="score">0</div>
            <div class="controls" style="margin-top:12px">
                <button id="subB" class="small">-1</button>
            </div>
            <div style="margin-top:8px;color:var(--muted)">Tap this panel to +1</div>
        </div>
    </div>

    <!-- leave some bottom space so content isn't jammed under fixed controls on wide screens -->
    <div style="height:12px"></div>
</div>

<!-- bottom area (will not be covered by fixed controls because bottom is offset) -->
<div class="bottomArea" id="bottomArea">
    <div class="collHeader" id="standingsHeader">
        <div style="font-weight:700">Tournament Standings</div>
        <div id="standingsToggle" class="muted">▼</div>
    </div>
    <div class="collContent" id="standingsContent" style="display:none">
        <table class="standingsTable">
            <thead><tr><th>Team</th><th>Wins</th><th>Losses</th><th>Points Scored</th><th>Points Conceded</th><th>PD</th></tr></thead>
            <tbody id="standingsBody"></tbody>
        </table>
    </div>

    <div class="collHeader" id="rosterHeader" style="border-top:1px solid rgba(255,255,255,0.03);">
        <div style="font-weight:700">Full Tournament Roster (8 Matches)</div>
        <div id="rosterToggle" class="muted">▼</div>
    </div>
    <div class="collContent" id="rosterContent" style="display:block">
        <table class="rosterTable">
            <thead><tr><th>#</th><th>Match</th><th>Court</th><th>Status / Result</th></tr></thead>
            <tbody id="rosterBody"></tbody>
        </table>
    </div>
</div>

<!-- fixed control bar -->
<div class="fixedControls" id="fixedControls">
    <button id="flip" class="small">Flip Sides</button>
    <button id="startMatch" class="primary small">Start Match</button>
    <button id="endMatch" class="ghost small">End Match</button>
    <button id="reset" class="small">Reset Scores</button>
</div>

<div class="toast" id="toast"></div>

<script type="module">
    //import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    // ---------- CONFIG ----------
    const FIXED_CONTROLS_HEIGHT = 56; // keep in sync with CSS --height
    // set CSS variable so bottomArea can use it
    document.documentElement.style.setProperty('--fixed-controls-offset', FIXED_CONTROLS_HEIGHT + 'px');

    const supabaseUrl = 'https://ygwqbzdhlpvhpuueyyov.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inlnd3FiemRobHB2aHB1dWV5eW92Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEzOTQ2NDUsImV4cCI6MjA3Njk3MDY0NX0._N7Pe1ugrzj83SNl4hUlqqIYQeN5Xed2G9SWftVw8-s';

    const supabase = createClient(supabaseUrl, supabaseKey);

    // ---------- Teams & roster ----------
    const TEAMS = {
        STT: { code:'STT', name:'Save The Tigers', color:'#fbc02d' },
        GIT: { code:'GIT', name:'God Is There', color:'#1976d2' },
        BD:  { code:'BD',  name: 'Button Dabavo', color:'#d32f2f' },
        KK:  { code:'KK',  name: 'Kattadi Karo', color:'#388e3c' }
    };

    const TOURNAMENT_ROSTER = [
        { n:1, teams:['STT','GIT'], court:1 },
        { n:2, teams:['BD','KK'], court:2 },
        { n:3, teams:['STT','BD'], court:1 },
        { n:4, teams:['GIT','KK'], court:2 },
        { n:5, teams:['STT','KK'], court:1 },
        { n:6, teams:['GIT','BD'], court:2 },
        { n:7, teams:['TOP2','TOP2'], court:1 },
        { n:8, teams:['BOT2','BOT2'], court:2 }
    ];

    // ---------- DOM refs ----------
    const matchSelect = document.getElementById('matchSelect');
    const newMatchBtn = document.getElementById('newMatchBtn');
    const statusLabel = document.getElementById('statusLabel');

    const sideA = document.getElementById('sideA');
    const sideB = document.getElementById('sideB');
    const teamAName = document.getElementById('teamAName');
    const teamBName = document.getElementById('teamBName');
    const scoreAEl = document.getElementById('scoreA');
    const scoreBEl = document.getElementById('scoreB');
    const subA = document.getElementById('subA');
    const subB = document.getElementById('subB');
    const flipBtn = document.getElementById('flip');
    const startBtn = document.getElementById('startMatch');
    const endBtn = document.getElementById('endMatch');
    const resetBtn = document.getElementById('reset');

    const standingsHeader = document.getElementById('standingsHeader');
    const standingsContent = document.getElementById('standingsContent');
    const standingsToggle = document.getElementById('standingsToggle');
    const rosterHeader = document.getElementById('rosterHeader');
    const rosterContent = document.getElementById('rosterContent');
    const rosterToggle = document.getElementById('rosterToggle');
    const standingsBody = document.getElementById('standingsBody');
    const rosterBody = document.getElementById('rosterBody');
    const bottomArea = document.getElementById('bottomArea');
    const fixedControls = document.getElementById('fixedControls');
    const toast = document.getElementById('toast');

    // ---------- state ----------
    let currentMatchId = null;
    let scoreA = 0, scoreB = 0;
    let currentStatus = 'created';

    // ---------- helpers ----------
    const uid = ()=> crypto.randomUUID?.() || 'id-'+Math.random().toString(36).slice(2,12);
    const showToast = (m,ms=1400)=>{ toast.innerText=m; toast.style.display='block'; setTimeout(()=> toast.style.display='none', ms); };
    const clamp = (n,m=0)=> n < m ? m : n;

    // render team UI
    function renderTeamUI(teamCodeA, teamCodeB){
        const aInfo = TEAMS[teamCodeA] ?? { code:teamCodeA, name:teamCodeA, color:'#666' };
        const bInfo = TEAMS[teamCodeB] ?? { code:teamCodeB, name:teamCodeB, color:'#666' };
        teamAName.innerText = `${aInfo.code} — ${aInfo.name}`;
        teamBName.innerText = `${bInfo.code} — ${bInfo.name}`;
        sideA.style.background = aInfo.color;
        sideB.style.background = bInfo.color;
    }

    function updateScoreDisplay(){ scoreAEl.innerText = String(scoreA); scoreBEl.innerText = String(scoreB); }

    // populate roster table
    function buildRosterRows(){
        rosterBody.innerHTML = '';
        TOURNAMENT_ROSTER.forEach(row=>{
            const tr = document.createElement('tr');
            tr.id = `roster-row-${row.n}`;
            const matchLabel = (row.teams[0] === 'TOP2' || row.teams[0] === 'BOT2') ? row.teams.join(' vs ') : `${row.teams[0]} vs ${row.teams[1]}`;
            tr.innerHTML = `<td>${row.n}</td><td>${matchLabel}</td><td>${row.court}</td><td id="roster-status-${row.n}">Pending</td>`;
            rosterBody.appendChild(tr);
        });
    }

    // calculate standings
    async function calculateStandings(){
        const { data: finishedMatches, error } = await supabase.from('matches').select('*').eq('status','finished');
        if(error){ console.error('standings fetch error', error); return []; }
        const stats = {};
        Object.keys(TEAMS).forEach(code => { stats[code] = { wins:0, losses:0, scored:0, conceded:0, pd:0 }; });
        finishedMatches.forEach(m=>{
            const a = m.team_a, b = m.team_b;
            const sa = Number(m.score_a || 0), sb = Number(m.score_b || 0);
            if(!stats[a]) stats[a] = { wins:0, losses:0, scored:0, conceded:0, pd:0 };
            if(!stats[b]) stats[b] = { wins:0, losses:0, scored:0, conceded:0, pd:0 };
            stats[a].scored += sa; stats[a].conceded += sb;
            stats[b].scored += sb; stats[b].conceded += sa;
            if(sa > sb){ stats[a].wins++; stats[b].losses++; }
            else if(sb > sa){ stats[b].wins++; stats[a].losses++; }
        });
        Object.keys(stats).forEach(k => stats[k].pd = stats[k].scored - stats[k].conceded);
        const ranked = Object.entries(stats).sort(([,A], [,B])=>{
            if(A.wins !== B.wins) return B.wins - A.wins;
            return B.pd - A.pd;
        });
        // render table
        standingsBody.innerHTML = '';
        ranked.forEach(([code, s])=>{
            const tr = document.createElement('tr');
            tr.innerHTML = `<td style="color:${TEAMS[code]?.color || '#fff'}">${code} (${TEAMS[code]?.name ?? code})</td><td>${s.wins}</td><td>${s.losses}</td><td>${s.scored}</td><td>${s.conceded}</td><td>${s.pd}</td>`;
            standingsBody.appendChild(tr);
        });
        return ranked.map(([code]) => code);
    }

    // refresh roster rows with finished match results
    async function refreshRosterDisplay(){
        const { data: finishedMatches } = await supabase.from('matches').select('*').eq('status','finished');
        function findMatchForPair(a,b){
            return finishedMatches.find(m => (m.team_a === a && m.team_b === b) || (m.team_a === b && m.team_b === a));
        }
        for(const row of TOURNAMENT_ROSTER){
            const statusCell = document.getElementById(`roster-status-${row.n}`);
            if(!statusCell) continue;
            if(row.n <= 6){
                const [a,b] = row.teams;
                const match = findMatchForPair(a,b);
                if(match){
                    const aScore = Number(match.score_a || 0);
                    const bScore = Number(match.score_b || 0);
                    const display = `${match.team_a} ${aScore} - ${bScore} ${match.team_b}`;
                    statusCell.innerText = display + (match.winner ? ` (Winner: ${match.winner})` : '');
                } else {
                    statusCell.innerText = 'Pending';
                }
            } else if(row.n === 7){
                const ranked = await calculateStandings();
                if(ranked.length >= 2){
                    statusCell.innerText = `${ranked[0]} vs ${ranked[1]} (Final)`;
                    const match = finishedMatches.find(m => (m.team_a === ranked[0] && m.team_b === ranked[1]) || (m.team_a === ranked[1] && m.team_b === ranked[0]));
                    if(match) statusCell.innerText = `${match.team_a} ${match.score_a} - ${match.score_b} ${match.team_b} (Winner: ${match.winner ?? '—'})`;
                } else {
                    statusCell.innerText = 'Top 2 teams TBD';
                }
            } else if(row.n === 8){
                const ranked = await calculateStandings();
                if(ranked.length >= 4){
                    const bottom = ranked.slice(-2);
                    statusCell.innerText = `${bottom[0]} vs ${bottom[1]} (3rd place)`;
                    const match = finishedMatches.find(m => (m.team_a === bottom[0] && m.team_b === bottom[1]) || (m.team_a === bottom[1] && m.team_b === bottom[0]));
                    if(match) statusCell.innerText = `${match.team_a} ${match.score_a} - ${match.score_b} ${match.team_b} (Winner: ${match.winner ?? '—'})`;
                } else {
                    statusCell.innerText = 'Bottom 2 teams TBD';
                }
            }
        }
    }

    // safe DB update guard
    async function safeUpdateScoresInDb(matchId, a, b){
        if(!matchId) return;
        const { data:row, error:err1 } = await supabase.from('matches').select('status').eq('id', matchId).single();
        if(err1){ console.error('status fetch error', err1); return; }
        if(!row) return;
        if(row.status === 'finished'){
            showToast('Match already finished — no changes allowed', 1800);
            await loadCurrentMatch();
            return;
        }
        const { error } = await supabase.from('matches').update({ score_a: a, score_b: b }).eq('id', matchId);
        if(error) console.error('update scores error', error);
    }

    // load matches list
    async function loadMatches(){
        const { data, error } = await supabase.from('matches').select('*').order('created_at',{ascending:false});
        if(error){ console.error(error); return; }
        matchSelect.innerHTML = '';
        data.forEach(m=>{
            const opt = document.createElement('option');
            opt.value = m.id;
            opt.text = `${m.team_a} vs ${m.team_b} (${m.status})`;
            matchSelect.appendChild(opt);
        });
        if(data.length > 0){
            currentMatchId = data[0].id;
            matchSelect.value = currentMatchId;
            await loadCurrentMatch();
        } else {
            currentMatchId = null;
            teamAName.innerText = '—';
            teamBName.innerText = '—';
            scoreA = scoreB = 0; updateScoreDisplay();
            statusLabel.innerText = 'idle';
        }
    }

    // load selected/current match
    async function loadCurrentMatch(){
        if(!currentMatchId) return;
        const { data, error } = await supabase.from('matches').select('*').eq('id', currentMatchId).single();
        if(error){ console.error('loadCurrentMatch error', error); return; }
        scoreA = data.score_a || 0; scoreB = data.score_b || 0;
        currentStatus = data.status || 'created';
        renderTeamUI(data.team_a, data.team_b);
        updateScoreDisplay();
        statusLabel.innerText = currentStatus;
    }

    // start / end match
    async function startMatch(){
        if(!currentMatchId){ showToast('No match selected'); return; }
        const { error } = await supabase.from('matches').update({ status:'running', start_time: new Date().toISOString(), score_a:0, score_b:0 }).eq('id', currentMatchId);
        if(error){ console.error('startMatch error', error); showToast('Error starting'); return; }
        scoreA = 0; scoreB = 0; currentStatus = 'running';
        statusLabel.innerText = currentStatus; updateScoreDisplay(); showToast('Match Started');
    }

    async function endMatch(){
        if(!currentMatchId){ showToast('No match selected'); return; }
        if(!confirm('End match and lock scores?')) return;
        let winnerCode = null;
        const aCode = teamAName.innerText.split(' — ')[0]?.trim();
        const bCode = teamBName.innerText.split(' — ')[0]?.trim();
        if(scoreA > scoreB) winnerCode = aCode;
        else if(scoreB > scoreA) winnerCode = bCode;
        const { error } = await supabase.from('matches').update({ status:'finished', end_time: new Date().toISOString(), score_a:scoreA, score_b:scoreB, winner: winnerCode }).eq('id', currentMatchId);
        if(error){ console.error('endMatch error', error); showToast('Error ending'); return; }
        currentStatus = 'finished'; statusLabel.innerText = currentStatus; showToast('Match Ended');
        await calculateStandings();
        await refreshRosterDisplay();
    }

    // local increment/decrement
    async function localIncrement(team){
        if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; }
        if(team==='A') scoreA++; else scoreB++;
        updateScoreDisplay();
        await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB);
    }
    async function localDecrement(team){
        if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; }
        if(team==='A') scoreA = clamp(scoreA-1,0); else scoreB = clamp(scoreB-1,0);
        updateScoreDisplay();
        await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB);
    }

    async function resetScores(){
        if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; }
        if(!confirm('Reset both scores?')) return;
        scoreA = 0; scoreB = 0; updateScoreDisplay();
        await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB);
    }

    // realtime subscription: update UI when matches change
    supabase.channel('public:matches')
        .on('postgres_changes', { event:'*', schema:'public', table:'matches' }, async payload => {
            const changed = payload.new;
            if(changed && currentMatchId && changed.id === currentMatchId){
                scoreA = Number(changed.score_a || 0);
                scoreB = Number(changed.score_b || 0);
                currentStatus = changed.status || currentStatus;
                statusLabel.innerText = currentStatus;
                renderTeamUI(changed.team_a, changed.team_b);
                updateScoreDisplay();
            }
            await calculateStandings();
            await refreshRosterDisplay();
        })
        .subscribe();

    // ---------- UI events ----------
    sideA.addEventListener('click', async (e) => {
        if(e.target === subA) return;
        if(!currentMatchId){ showToast('Select or create a match'); return; }
        if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; }
        scoreA++; updateScoreDisplay();
        await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB);
    });
    sideB.addEventListener('click', async (e) => {
        if(e.target === subB) return;
        if(!currentMatchId){ showToast('Select or create a match'); return; }
        if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; }
        scoreB++; updateScoreDisplay();
        await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB);
    });

    subA.addEventListener('click', async (e)=>{ e.stopPropagation(); if(!currentMatchId) return; if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; } scoreA = clamp(scoreA-1,0); updateScoreDisplay(); await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB); });
    subB.addEventListener('click', async (e)=>{ e.stopPropagation(); if(!currentMatchId) return; if(currentStatus === 'finished'){ showToast('Match finished — no changes'); return; } scoreB = clamp(scoreB-1,0); updateScoreDisplay(); await safeUpdateScoresInDb(currentMatchId, scoreA, scoreB); });

    flipBtn.addEventListener('click', ()=>{
        const aName = teamAName.innerText, bName = teamBName.innerText;
        const aBg = sideA.style.background, bBg = sideB.style.background;
        teamAName.innerText = bName; teamBName.innerText = aName;
        sideA.style.background = bBg; sideB.style.background = aBg;
        [scoreA, scoreB] = [scoreB, scoreA];
        updateScoreDisplay();
    });

    startBtn.addEventListener('click', async ()=>{ if(!currentMatchId){ showToast('Select or create a match'); return; } await startMatch(); });
    endBtn.addEventListener('click', async ()=>{ if(!currentMatchId){ showToast('Select or create a match'); return; } if(!confirm('End match and lock scores?')) return; await endMatch(); });
    resetBtn.addEventListener('click', async ()=>{ await resetScores(); });

    newMatchBtn.addEventListener('click', async ()=>{
        const team_a = prompt('Enter Team A code (STT/GIT/BD/KK):');
        if(!team_a) return;
        const team_b = prompt('Enter Team B code (STT/GIT/BD/KK):');
        if(!team_b) return;
        const id = uid();
        const payload = { id, team_a: team_a.trim().toUpperCase(), team_b: team_b.trim().toUpperCase(), score_a:0, score_b:0, status:'created', created_at: new Date().toISOString() };
        const { error } = await supabase.from('matches').insert(payload);
        if(error){ console.error('create match error', error); showToast('Error creating match'); return; }
        await loadMatches();
        matchSelect.value = id; currentMatchId = id; await loadCurrentMatch();
        showToast('Match created');
    });

    matchSelect.addEventListener('change', async ()=>{
        currentMatchId = matchSelect.value;
        await loadCurrentMatch();
    });

    // ---------- Collapsible toggles (improved) ----------
    function openSection(contentEl, toggleEl){
        contentEl.style.display = 'block';
        toggleEl.textContent = '▲';
        // ensure bottom area is visible (smooth)
        setTimeout(()=> bottomArea.scrollIntoView({ behavior:'smooth', block:'end' }), 50);
    }
    function closeSection(contentEl, toggleEl){
        contentEl.style.display = 'none';
        toggleEl.textContent = '▼';
        setTimeout(()=> bottomArea.scrollIntoView({ behavior:'smooth', block:'end' }), 50);
    }

    standingsHeader.addEventListener('click', ()=>{
        const isHidden = standingsContent.style.display === 'none';
        if(isHidden) openSection(standingsContent, standingsToggle); else closeSection(standingsContent, standingsToggle);
    });

    rosterHeader.addEventListener('click', ()=>{
        const isHidden = rosterContent.style.display === 'none';
        if(isHidden) openSection(rosterContent, rosterToggle); else closeSection(rosterContent, rosterToggle);
    });

    // ---------- init ----------
    (async function init(){
        buildRosterRows();
        await loadMatches();
        await calculateStandings();
        await refreshRosterDisplay();

        // ensure bottomArea bottom offset matches fixed controls height (JS-side too)
        // This also helps if you change FIXED_CONTROLS_HEIGHT at top
        bottomArea.style.bottom = FIXED_CONTROLS_HEIGHT + 'px';
        // when small screen, we already handle with CSS to make bottomArea static
    })();
</script>
</body>
</html>
